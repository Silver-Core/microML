\documentclass[12pt, a4paper]{report}
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage{amsmath}
\usepackage{minted}
\usepackage{palatino}
\usepackage{syntax}
\usepackage{geometry}
\usepackage[hidelinks]{hyperref}
\usepackage{tikz}
\usetikzlibrary{matrix}
\usepackage{color, colortbl}
\definecolor{Seagreen}{rgb}{0.18, 0.54, 0.34}
\definecolor{Lawngreen}{rgb}{0.48, 0.99, 0}
\definecolor{LRed}{rgb}{1, 0.8, 0.8}
\definecolor{GoldenRod}{rgb}{0.93, 0.65, 0.12}
\usepackage[center]{titlesec}
\linespread{1.3}
\usepackage{verbatimbox}

\begin{document}
\begin{titlepage}
	\centering
%	\includegraphics[width=0.15\textwidth]{example-image-1x1}\par\vspace{1cm}
        {\scshape\LARGE University College London\par}
	\vspace{1cm}
        {\scshape\Large MSc Computer Science Final Project\par}
	\vspace{1.5cm}
        {\huge\bfseries microML \\ A Language for the BBC micro:bit \par}
	\vspace{2cm}
        {\Large\itshape David Kelly\par}
	\vfill
	supervised by\par
        Rae \textsc{Harbird}

	\vfill
        {\large \today\par}

        \vfill

        This report is submitted as part requirement for the MSc Computer Science
        degree at UCL\. It is substantially the result of my own work except where ex-
        plicitly indicated in the text.
        
        \vfill

        The report may be freely copied and distributed provided the source is explicitly
        acknowledged.

    \end{titlepage}

\tableofcontents

\newpage

\begin{abstract}
    It is increasingly being recognized in educational circles that introductory lessons in programming is a
    vital part of the modern school curriculum. Programming education in UK has not traditionally
    formed part of the syllabus. Nearly all teenagers have access to computers and devices, but very
    few know how to program them themselves. The raspberry pi has seen a remarkable growth in
    popularity since its introduction a mere four years ago. The BBC micro:bit is a project in the
    same spirit as the raspberry pi, but with a remit specifically for UK secondary school students.

    MicroML is an attempt to bring the fundamental concepts of the functional programming paradigm
    to the micro:bit, and thusly to the large body of untapped talent lying in Britain's secondary
    schools. It should allow the students to explore such ideas as recursive thinking, structural
    induction, polymorphism and higher order types without ever having to be exposed to the
    underlying theory of such things, something which no other functional language does. 

    The project was conceived and written in Haskell. It does not build on any other existing
    project. Apart from reliance on standard Haskell libraries all of the major design work was
    written `ab nihilo', including syntax design, the parser, type inference and the compiler. 

    MicroML, at point of submission, is a strong base from which to do further work. It has
    polymetric type inference, markdown-style inline documentation, a fully-featured repl
    environment with extensive error checking capabilities, the ability to check source code for
    common programming errors (such as duplicate function definitions and unreachable functions) and
    produce images of program call graphs. It has been designed with the principle aim of making a
    environment conducive to learning, without being condescending.

\end{abstract}

\chapter{Introduction}

\begin{flushright}
    \textit{'a monad is a monoid in the category of endofunctors, what's the problem?'} \\
    --- not Philip Wadler\footnote{The quote is actually from \textit{A Brief, Incomplete, and Mostly
            Wrong History of Programming Languages by James Iry
            \url{}https://james-iry.blogspot.co.uk/2009/05/brief-incomplete-and-mostly-wrong.html},
        where it is deliberately falsely attributed,
        but it is itself a close paraphase from \textit{Categories for the Working Mathematician}.}
\end{flushright}

\section{Motivation}
The Walder quote might be spurious, but a genuine piece of documentation for the Control.Monad.Trans.EitherT
library\footnote{\url{https://hackage.haskell.org/package/either-4.4.1.1/docs/Control-Monad-Trans-Either.html}}
available on \textit{Hackage} informs us that `an apomorphism is the generalized anamorphism for this 
Monad'.  Such statements, while (almost certainly) factually correct are of little use to the
average `jobbing' programmer and indeed might be considered to have the effect of deliberately alienating a large part
of the software engineering workforce. One can only hope that this was not the intention, because
functional languages, especially those which use static type analysis and inference, have a great
deal to offer to the programming community in terms of expressiveness and safety. Must it be the
case therefore that introductory material is so intimidating? Is there a way to encourage students
to think functionally, in a type-orientated manner, without the heavy mathematical baggage that is
simple surplus to requirements when writing one's first programs?


\section{Aims and Goals}
\subsection{Project Aims}
It seems only apposite that a functional language for the micro:bit, assuming that it is not
self-hosting, should be written in a more mature functional language. Haskell was chosen for this
task as it presented a good opportunity to `come to grips' with the language and the paradigm. A
single 10-week module in Miranda was not, as anticipated, sufficient preparation for the complexity
of constructing an entire program in a language which is almost aggressive in its focus on purity. 

The primary target, or goal, of the project is to produce, as a first iteration, the basis of a
language designed primarly for teaching purposes, but practical enough to write real programs for
the micro:bit. Many languages have been implemented over the years with the express aim of teaching
programming concepts. Perhaps the most famous and successful of these is Scheme. However, what they
all have in common is that they are intended for an audience who are already interested in computer
science, or are indeed computer scientists. Even classic texts, such as \textit{The Implementation
    and  Interpretation of Computer Programming} is squarely pitched at a sophisticated audience.
The micro:bit is the opposite: it is for students with no previous programming experience,
students who are not mathematicians, teachers who are neither mathematicians nor programmers.
Functional programming has a reputation in the programming community as being complex and only for a
special type of person. The aim of this project is to show that this is not necessarily be the case.
With this in mind, the aim is to make the language as education as possible, at the expense of
sacrificing expressiveness. 

Mention here no call with current continuation or macros, as obscuring underlying goals, which are
inductive reasoning and intro to types and function composition.

Development progressed iteratively. Having no previous experience of engineering a large software
project in Haskell, initial development was largely \textit{ad hoc} and unstructured. A great deal
of time was spent just in understanding the principles of state manipulation in a side-effect free
language. Luckily there were a number of tutorials which served as the backbone, or perhaps more
accurately, foetus, of the final project. Traces of these tutorials can still be seen scattered
throughout the final codebase. These were perhaps both a help and a hinderance, as their original
authors had not perhaps foreseen that they would be so heavily expanded and built-upon. Strong
foundations might have results in a project which was more realised, with fewer edge cases and areas
where the solutions are not as robust as could be desired. \\

\subsection{Project Goals}
Formally put, the project's goals were \\

\begin{itemize}
    \item Create an uncluttered syntax for a functional language. The initial inspiration was a
        mixture of Scheme and Miranda. Scheme was considered the better model for evaluation (but
        not for syntax) as it is very simple and relatively pure. While Scheme lacks such items as algebraic data types
        and pattern matching, it clearly exposes the underlying lambda calculus.
    \item Write a repl environment for students to explore code and concepts. All modern languages
        ought to have a repl, so that individual snippets of code can be tested without the delay of
        compilation and the increased difficulty of pinpointing errors. The repl environment ought
        to be `friendly' and provide as much assistance to the user as possible. 
    \item Have effective type inference so that students do not need to explicitly type variables.
        While not every functional language has type inference\footnote{Idris, a dependently typed language,
            requires type annotations due to the undecidability of inference of dependent types.},
        it is a fundamental feature of the ML family. Having type inference means that the `truth'
        of types is not hidden from the student as it would be with JavaScript or Python, but the
        onus of type annotations is also absent.
    \item Compiler to micro:bit flavoured C++. This was the part of the project which was most
        pertinent to the micro:bit, but also that which would require the most time to bring to a
        degree where compilation of even complicated programs could be accomplished with safety and
        precision. 
\end{itemize}

\chapter{Context}
\section{The BBC micro:bit} The BBC micro:bit is a microprocessor device aimed at
bringing programming to young adults and teenagers. At present it supports a number of 
different programming languages, most visibly \textit{MicroPython, JavaScript} and \textit{TouchDevelop}.
These languages, while mainstream and popular,\footnote{With the exception of \textit{TouchDevelop}
    of course.} all fundamentally support the same programming paradigm, the imperative. Doubtless it is
vital for all would-be coders to have knowledge and experience with the imperative/procedural
approach to structuring code, but it is not the only approach, and perhaps not the best for
beginners or those with only a passing interest in coding. It is the contention of the author that a
syntactically simple, (relatively) \textit{pure} functional language would make for an ideal 
teaching tool on the micro:bit, allowing the student to focus almost entirely on the problem domain, 
and a great deal less on syntax and \textit{boilerplate}.
Functional languages are increasingly being used in every area of real-world applications. Regarding 
robotics, in which Rae has expressed an interest, there has already been some research conducted 
in the use of the declarative style for low level robotics programming\footnote{Lambda in Motion: Controlling
    Robots with Haskell, Peterson John, Paul Hudak and Conal Elliott}. This at least demonstrates
that the functional style is applicable to the problem area, but further research would be required
to test the suitability of the micro:bit as a low-level controller. Certainly, anything which can be
programmed in microPython could also be written (possible more briefly and with fewer bugs) in a
functional language.

\section{Teaching Languages}
There is a long history of languages designed with the express purpose of teaching rather than
production. These generally fall into two streams of development: reduced versions of established
professional languages, and graphical environments. In general, the visual programming languages, of
which \textit{Scratch} is undoubtedly the most well established, are intended for a younger age
group. On the micro:bit \textit{Microsoft Block Editor} is of this variety. 
\textit{Microsoft Touch Develop} and \textit{Code Kingdoms JavaScript} appear to offer a hybrid
experience, with textual code presented in a coloured, graphical editor. Finally there is a port of
the \textit{Python} programming language, which best typifies that school of tuition where a real
langage is used in a simplified context.

\section{Python as Teaching Language}
While Python was not explicitly designed as a teaching language, in recent years it has increasingly
been used as an introductory language in university settings. MIT, where Scheme was first created
and promoted, has begun to teach its introductory courses in Python. With Python already available
on the micro:bit, why is there the need for another text-based language on the same platform? Is
this not just `muddying the waters' of what should be a simple educational tool. Do instructors
really have the time to learn another language if students should express an interest in programming
functionally?


\section{Python vs Miranda/Haskell}
In an attempt to address some of these questions, it is necessary to derive some picture of what might
constitute a functional language, and why it might be a useful way to teach programming to younger
learners. Being more a philosophical stance than technical necessity, it is possible to mix various
paradigms together to form \textit{hybrid} languages. In practice, most programming languages take
precisely this approach\footnote{Truly pure languages are a rare thing: in the realms of OOP perhaps
only \textit{Smalltalk} and \textit{Ruby} qualify. In the functional language family, the only
mainstream entirely pure language is Haskell.}. Python, for example, supports a great deal of the 
functional paradigm, as does JavaScript. These already exist on the micro:bit: why not just use those? 
Consider the following simple scenario, we want to sum all the occurrences of the number 3 in the
following list: 

\mint{python}|nums = [2,3,4,3,2,3,5]|

To do this in an imperative manner, something like the following might be written:

\begin{minted}{python}
    sum = 0
    for i in range(len(nums)):
        if nums[i] == 3:
        sum += 3
\end{minted}

To solve this in Python using functional concepts, something like this might be used:

\mint{python}|sum(list(filter((lambda x: x == 3), nums)))|

This is clearly an improvement in terms of brevity, and is perhaps a little easier to understand. The
main difficulty here in the physical writing of the code is balancing the parentheses, but any good
editor should be able to do this automatically. The filter
higher order function \textit{filter} has a fairly clear meaning to any native English speaker.
However the rather obscure use of \textit{list} and, even worse, \textit{lambda} still makes
this rather difficult for the student. There is a number of topics which would need to be explained
here which reduce the utility of this as a teaching example. Why is the syntax still relatively
cumbersome? Because Python was not conceived as a functional language, many of these features have
been grafted onto a traditional imperative substructure, and the syntax reveals this.
The equivalent function in Haskell would be:

\mint{haskell}|sum (filter (==3) nums)|

Haskell provides some syntactic sugar to reduce the number of brackets even 
further\footnote{Apologies for the slightly misleading typography here, the package being used for
syntax highlighting seems unable to properly interpret \LaTeX escape symbols. It should read simply \$.}


\mint{haskell}|sum \$ filter (==3) nums|    
To make all of this code more generic the Python needs to be wrapped in a function definition:

\begin{minted}{python}
    def sumAllOccurrences(n, nums):
        sum = 0
        for i in range(len(nums)):
            if nums[i] == n:
                sum += n
        return sum
\end{minted}

And the equivalent in Haskell:

\mint{haskell}|sumAllOccurrences n ns = sum \$ filter (==n) ns|

In fact, we can do even better than this:

\mint{haskell}|sumAllOccurrences p ns = sum \$ filter p ns|

where p is any predicate we care to pass in, such as (==3) or (\textless2). The python code does not prevent
someone from passing in junk values (leading to a runtime error) but the Haskell code, with the
addition of a simple \textit{type signature} can easily be altered to only receive integers,
ensuring type safety. This need not be explained to the student in these terms, but they will
benefit from their program not crashing in unexpected and difficult to detect ways.

\begin{minted}{haskell}
    sumAllOccurrences :: (Int -> Bool) -> [Int] -> Int
    sumAllOccurrences p ns = sum \$ filter p ns
\end{minted}

This is more powerful than the equivalent Python for loop definition, and a great deal more
flexible. Obviously this could also be implemented in python using filters and lambda expressions,
but it would still need to be couched inside a function definition.\footnote{This is slightly
disingenuous, as a list comprehension, in both Python and Haskell, would work well here. It does
serve to illustrate the general point. Of course, list comprehensions were first introduced in
functional programming languages.}. In this simple example much of the essence of the functional
programming style can be seen. The advantages are clear: fewer lines of code usually means fewer bugs and less
development time. Students can get to solving problems almost immediately, without the worry (or
rather a reduced worry) about the syntactical correctness of their loops, or balancing a host of
nested parentheses. 
Haskell is a large and complicated language and not suitable for younger students\footnote{make a
    reference here or somewhere to the eitherT library, by Kmett}. Its runtime is
large and complex, and would almost certainly not run efficiently on the micro:bit. Its emphasis on
purity has led it to introduce a number of features which, while theoretically elegant, are
complex even for experienced programmers. There is however a family of other, related, languages, mostly
descended directly or indirectly from ML\footnote{Excepting the Lisp family representatives,
\textit{Common Lisp} and \textit{Scheme}}, which place different emphasis on parts of the functional
paradigm.\footnote{The table is a simplified (and slight corrected) version of the available from
\url{https://en.wikipedia.org/wiki/Comparison_of_functional_programming_languages}. Monads, monoids
and functors, while important concepts in functional languages, are definitely out of scope for a
teaching language to teenagers. The approach taken by \textit{Miranda} is that which will be followed
in the suggested implementation, hiding unnecessary detail with the loss of a little referential
transparency.}

\section{Research}
With the thought in mind of creating a Miranda style language for the micro:bit, came the necessity
to decide on the technologies and theoretical basis for the language. Being an implementation of the
lambda calculus, it was necessary to choose an axis on the \textit{lambda cube} for further
development. 

\subsection{The Lambda Cube}
The Lambda Cude was introduced by mathematician Henk Barendregt as a visualization framework for
Coquand's calculus of contructions. The simple untyped lambda calculus is not represented.


\begin{tikzpicture}
  \matrix (m) [matrix of math nodes, row sep=3em,
    column sep=3em]{
        & \lambda\omega & & \lambda P \omega \\
        \lambda 2 & & \lambda P 2 & \\
        & \lambda \underline{\omega} & & \lambda P \underline{\omega} \\
        \lambda \rightarrow & & \lambda P  & \\};
  \path[-stealth]
    (m-1-2) edge (m-1-4) edge (m-2-1) edge (m-3-2)
    (m-1-4) edge (m-3-4) edge (m-2-3)
    (m-2-1) edge [-,line width=6pt,draw=white] (m-2-3)
            edge (m-2-3) edge (m-4-1)
    (m-3-2) edge (m-3-4)
            edge (m-4-1)
    (m-4-1) edge (m-4-3)
    (m-3-4) edge (m-4-3)
    (m-2-3) edge [-,line width=6pt,draw=white] (m-4-3)
            edge (m-4-3);
\end{tikzpicture}

This can be understood as a exploring refinements of of type lambda calculi. Starting in the bottom
left hand corner $\lambda \rightarrow$ is the simply type lambda calculus as developed by Church,
Curry and Feys in the 1940s\footnote{Types and Programming Languages p11 gives a simple timeline of
    type theory research.}. The top right corner, the `summit' of calculi is $\lambda P \omega$, which
represents dependent types. Perhaps no truly practical programming language occupies this space at
present. Theorem provers, such as \textit{Coq} have not been used for enterprise software, and
perhaps it is not possible to do so. \textit{Idris}, a dependently typed programming language
written in Haskell is an attempt to write a general programming language with depenent types. It is
too early in its development at this stage to say whether it will meet with success. A number of
issues, principally the undecidability of type inference over dependent types, would seem to be a
limiting factor to general acceptance. 

Naturally, microML makes no attempt to implement $\lambda P \omega$. `Real world' functional
languages, such as Haskell, actually implement hybrid systems which are not represented on the cube.
Most importantly, subtyping (represented as $\lambda F_{<:}$) is missing as a construct from the cube, 
even though almost all language which support record syntax must allow some form of subtyping.

$\lambda 2$, or \textit{System F} is that system which allows for parametric polymorphism (often
called \textit{generics} in such languages as Java and C++). This seemed a suitable target for
microML's type system. It has the added advantage that there is a well-established algorithm, Damas
--- Milner algorithm W, which runs in $\mathcal{O}n$ time for non-pathological input\footnote{Worst case
    complexity for algorithm W actually falls into exponential time, but an input program would have
    to be both perversely written and extremely large before this would become a significant
    liability.}. Type inference was deemed an important addition to microML as introducing the
concept of types, which though fundamental to modern computing, carries the risk of rendering it too
difficult and different conceptually from the other languages already available on the micro:bit.
These all have in common so-called \textit{duck} typing, and interaction with the type system,
programming with types as it were, is against the nature of the language itself. This is especially
true of Python, which discourages direct type checking on the part of the programmer (though such
facilities do exist.). Good type inference, with easy to read error messages, is an essential
feature of microML without which it would struggle to justify its existence.

\section{Sources}
This project has drawn on a large variety of sources, some only tangentally, but others central to
the realization of the project, without which microML, as embryonic as it might be, would not exist
at all. A number of tutorials (detailed in the bibilography) gave a strong starting position upon
which to build. Luckily there are a number of trivial examples of repls written in Haskell which
give an idea of what might be accomplished. Full scale compilers are a little more unusual, but such
classic texts as `Modern Compiler Implementation in Standard ML', the so-called \textit{Tiger Book},
can be adapted to Haskell with minimal inconvenience. For type theory the central text is
undoubtedly `Types and Programming Languages' without which many a tutorial on type inference would
have remained decidedly opaque.

Many papers were consulted initially while deciding on the best approach for microML's type system.
In practice, very little of this reading has made it into the language as currently constituted, but
it is hoped that the design allows for future development to integrate some of these possible
features easily. Always bearing in mind of course the intended scope of the language. This perhaps
was one of the most difficult design decisions: what had a legitimate place in a language for a
simple processor aimed at teachers, and what could be implemented simply for the interests of the
developer, or because it was simple to do? Design decisions based on ease of implementation or to
please the vanity of the designer are correct only be coincidence, and this is a poor way to
design\footnote{This recalls Tony Hoare's `Billion Dollar Mistake'.}.

\section{Software, Tools, Libraries}
Haskell is ideally suited to the creation of DSLs. This is largely due to its \textit{algebraic data
    types} which can easily be used to represent the BNF of an embedded language. Morever Haskell is
blessed with the Parsec library of parser combinators\footnote{A \textit{combinator} is simply a
    function with no free variables, so it only operates on parameters directly passed to it without
    reference to any global data within the function body.}, which mitigates against the necesssity of
writing lex and yacc files to create a functioning parser. A parser for another language can be
implemented directly in Haskell, using standard Haskell syntax. Haskell moreover has an extensive
library system, located on \textit{Hackage}. There is a library for almost any conceivable
requirement. Haskell has two main build tools for project management. Neither is as tightly
integrated into the language as might be ideal. One need only compare newer languages, such as Rust
and Elixir, where the build tools (Cargo and Mix in this case) are an integral part of the language,
to realize that both \textit{Cabal} and \textit{Stack} have a rather \textit{ad hoc} appearance.

All Hackage packages are availalbe through Cabal, but version management is not rigourously
enforced. Builds can break easily and frequently. So-called `Cabal dependency
Hell'\footnote{\url{https://wiki.haskell.org/Cabal/Survival}} is a real problem, especially for
those with no prior experience with the tool. It is poor design to inflict such problems on an end
user who only wants to build a piece of software from source rather then having the programmer
subsume them. Stack helps in this direction but maintaining a stable list of packages and creating a
strong sandboxed environment for development. The price to be paid is a reduced number of availalbe
libraries, so build problems can still occur over external dependencies. MicroML was firstly a Cabal
project, but was migrated to Stack later in development. This largely produced a more stable
build and allowed for the use of \textit{intero}\footnote{intero is an alternative to ghci --- the
    Haskell interactive environment, but provides better type information and error messages,
    moreover it has good integration with neovim, the author's editor of choice.} but unfortunately also meant that some experimental
code (specially the JIT compiler) had to be disabled. This will be discussed more fully in chapter
<unknown>.

Some libraries and approaches were abandoned during the development process. Most notably a deal of
time was put into using the \textit{Language-C} library for manipulating the C AST in Haskell. While
this would certainly be the correct approach for writing the C code generation element of microML,
it was decided that time constraints did not allow for proper utilization of the library (which is
very large) so other alternatives were explored in the hope of at least producing a testable backend
within the timeframe of the project. 

\chapter{Requirements and Analysis}

nothing here yet

\chapter{Design and Implementation}

microML uses an enriched lambda calculus as its base
\vspace{5mm}

\begin{minipage}[t]{0.5\textwidth}
    \begin{grammar}
        <Expr> ::= Var
        \alt{} Constructor 
        \alt{} Application <Expr> <Expr>
        \alt{} Let Name <Expr> <Expr>
        \alt{} Literal 
        \alt{} If <Expr> then <Expr> else <Expr>
        \alt{} FixPoint <Expr>
        \alt{} UnaryOp <Expr>
        \alt{} BinOp <Expr> <Expr>
        \alt{} PrimitiveErr 
    \end{grammar}
\end{minipage}
\begin{minipage}[t]{0.5\textwidth}
    \begin{grammar}
        <Literal> ::= Integer
        \alt{} Double
        \alt{} Boolean
        \alt{} String
        \alt{} Char
        \alt{} Tuple of <Literal>
    \end{grammar}
\end{minipage}
\vspace{5mm}

In addition to these basic primitives and control structures, microML also makes use of three
primitives inherited from languages in the Lisp family:

\begin{grammar}
    <ListOp> ::= Car
    \alt{} Cdr
    \alt{} Cons
\end{grammar}

These primitives are accessed through the \textit{head}, \textit{tail} and (:) built-in functions and are
essential for recursing over lists.\

microML, in addition to floats and ints, also supports binary, octal and hex numbers\footnote{The
    syntax for these is inspired by erlang, one simply writes the number in the form eg 2\#110 for a
    binary 6. Likewise octal is 8\# and hex 16\#}. These are not
treated as primitives however, and are automatically converted to an appropriate representation.

The \textit{FixPoint} primitive allows for the creation of recursive functions by satisfying the equation
\begin{flalign*}
    &y\ f\ = f (y\ f) &
\end{flalign*}

The most famous fix-point combinator without a doubt is Curry's \textit{Y-combinator}:
\begin{flalign*}
    &Y = (\lambda f. (\lambda x.\ f (x x)) (\lambda x.\ f (x x))) &
\end{flalign*}

To see how this can be used to simulate recursion\footnote{there are many excellent texts which
    give detailed explanations of the \textit{Y-combinator}, such as \dots } it is necessary simply
to supply an argument in the form of a lambda abstraction.

\begin{eqnarray*}
    && Y g = (\lambda f. (\lambda x.\ f (x x)) (\lambda x.\ f (x x))) g \\
    & \to_\beta & (\lambda x.\ g (x x)) (\lambda x.\ g (x x)) \\
    & \to_\beta & g ((\lambda x.\ g (x x)) (\lambda x.\ g (x x))) \\
    & \equiv & g (Y g)
\end{eqnarray*}

While two different number types are supported by the parser, the type checker only recognizes the
type \textit{Number}. The compiler will benefit from knowledge of the number type, ie int or double,
whereas the user (a school-aged student) will not.

\section{Parsing}
A number of different libraries were examined before settling on the `standard'
\textit{Parsec} library of parser combinators\footnote{A combinator is a lambda expression which
    contains no occurrences of a free variable, ie all of its arguments are
    explicitly supplied to it, and it does not rely on any global state or globally defined
    variables}. \textit{Parsec} is a highly
flexible tool, perhaps more similar to \textit{ANTLR}\footnote{\url{http://www.antlr.org/}} than to
\textit{Yacc} or \textit{Bison}. Explicit regular expressions are not required, as the parser /
lexer is a composite of a great number of small, specialized parser functions, which are linked
together. If one parser fails, the next is tried until either parsing succeeds or a fatal error
occurs. 

Other libraries, such as \textit{MegaParsec} and \textit{Trifecta}, both respected and
powerful, were examined. Trifecta especially seems like a very interesting parsing library,
with excellent support for detailed, custom error messages. This would have been ideal for a
teaching language of the nature of microML: unfortunately there is an almost total absence of
documentation on the use of Trifecta, and internet tutorials of any size beyond the trivial 
do not seem to exist. The programming
language \textbf{Idris} uses Trifecta for its parser, so future iterations of microML might be able
to migrate to Trifecta after careful examination of the Idris source. 

MegaParsec has excellent
support for indentation sensitive grammars, which Parsec does not. Again, this would be a useful
feature to add to microML at a later stage of development. It seems to be however, at the present time, misplaced
energy to focus on what is essentially syntactic sugar when other, more vital, elements of the
project are still not functioning as they should or have not even been started. Moreover, MegaParsec
is a relatively new, and non-standard, library whereas most installations of Haskell ship with
Parsec as a component of the standard library. Of course, eschewing the new in favour of that which
is ubiquitous (often in the name of backwards compatibility) is a bad habit which retards the
development of better software. In this case however, the added power of MegaParsec is not yet
required.

Formally, parsec belongs to the family of LL(1) parsers. Obviously this does slightly reduce the
flexibility of the language design\footnote{LL(1) parsers can only recognize a subset of the
    context-free languages.}. Haskell itself does not use an LL(1) parser, but rather an LALR(1)
built using \textit{Happy} and \textit{Alex}, much in the manner of a parser constructed using
\textit{Yacc}, but such power is not required for the much more limited range of expression
available in microML. If the language were ever to be expanded or made more robust, it would perhaps
be reasonable to rewrite the parser to make use of this model.

\section{Type Inference}
microML uses an implementation of
\textit{algorithmW}\footnote{based on the following tutorial implementation
    \url{https://github.com/wh5a/Algorithm-W-Step-By-Step/blob/master/AlgorithmW.lhs}} for ML-style type inference. At present it is
not possible to declare the types of functions, they can only be inferred. As this is primarily a
teaching language with a very simple type system, this is not the drawback that it might otherwise
be. 

A full description of Hindley-Milner type inference is beyond the scope of this report, however a
brief overview of the concept is appropriate.

At a trivial level, primitives have a predetermined type, so \textbf{(Lit (LInt 4))} has type
\textbf{Number}, likewise \textbf{(Lit (LBoolean true))} has type \textbf{Boolean}.

At a slightly higher level, many operators only work on certain types, so the presence of these
operators can help the inference system to resolve the constraints. For example

(+) is defined to work only on objects of type Number.

An expression of the type \textit{true + false} will fail with a \textit{unification error} as (+)
is not a supported operator for this data type.

Hindley-Milner is guaranteed to give the most general type signature possible. MicroML supports
\textit{polymorphic} types. For example, the \textit{higher order} function 
`twice'\footnote{called `ap' in Haskell} has the form

\begin{minted}{haskell}
    twice f x = f (f x)
\end{minted}

which has the type
\begin{flalign*}
    & for\ all\ a. (a \rightarrow a) \rightarrow a \rightarrow a &
\end{flalign*}

The opening parentheses indicate that the first argument to \textit{twice} must be a function that
takes one input of type `a' and maps it to something of the same type. The next `a' refers to x, and
must be of a type accepted by the function f. The final result of the function must also be of the
same type. It is not important what type `a' actually is, as long as these contraints hold. Herein
lies the true power of type inference.

\end{document}
