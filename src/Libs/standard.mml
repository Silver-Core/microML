--GLOSSARY--
(*
==unary== 
***unary***
a **unary** function only takes **1** argument
#Example:#
    > zero? 3           **zero? only takes one argument**
    > false : Boolean
    > zero? 3 4         **doesn't make any sense!**
however
    > zero? (3 - 3)     **this is ok**
    > true : Boolean
*)
(*
==boolean==
***boolean***
a true or false value
*)
(*
==higher order function==
***higher order function***
a higher order function is a function that does one (or both) of the two following things
    > takes one or more functions as arguments (c.f flip)
    > return a function as a result
*)
(* 
==id==
***id***
** id :: a -> a **
id is a __unary__ function. It returns what was given to it without changes, throwing away extra arguments
#Example:#
    > id 5
    > 5 : Number
    > id 'a'
    > a : Char
*)
let id x = x
(* 
==zero?== 
***zero?*** 
** zero? :: Number -> Boolean ** 
zero checks if a number or value is equal to 0
#Example:#
    > let x = 1
    > zero? x
    > false : Boolean
*)
let zero? x = if x == 0 then true else false;
(*
==odd?==
***odd?***
** odd? :: Number -> Boolean **
odd? checks if a number is odd, returning a __boolean__ value.
#Example:#
    > odd? 5
    > true : Boolean
    > odd? 4
    > false : Boolean
*)
let odd? x = if x % 2 == 1 then true else false;
(*
==even?==
***even?***
** even? :: Number -> Boolean **
even? checks if a number is even, returning a __boolean__ value.
#Example:#
    > even? 4
    > true : Boolean
    > even? 5
    > false : Boolean
*)
let even? x = if x % 2 == 0 then true else false;
(*
==positive?==
***positive?***
** positive? :: Number -> Boolean **
positive? checks if a number is positive, returning a __boolean__ value.
#Example:#
    > positive? 4
    > true : Boolean
    > positive? (-5)
    > false : Boolean
*)
let positive? x = if x > 0 then true else false; 
(*
==negative?==
***negative?***
** negative? :: Number -> Boolean **
negative? checks if a number is negative, returning a __boolean__ value.
#Example:#
    > negative? (-4)
    > true : Boolean
    > negative? 5
    > false : Boolean
*)
let negative? x = if x < 0 then true else false;
(*
==show==
***show***
** show :: for all a. a -> String **
show takes a value and returns it as a string
#Example:#
    > show 3
    > "3" : String
    > show 'a'
    > "a" : String
*)
let show x = x; 
(* 
==const==
***const***
** const :: for all a b. a -> b -> a **
const return only the first of its two aruments, throwing the second away
#Example:#
    > const 3 4
    > 3 : Number
    > const 'a' "hello"
    > 'a' : Char
Note that const is __polymorphic__: it can take two arguments of any type, the same or different.
*)
let const x y = x;
(*
==succ==
***succ***
** succ :: Number -> Number **
succ adds one to a number
#Example:#
    > succ 3
    > 4 : Number
*)
let succ x = x + 1;
(*
==flip==
***flip***
** flip :: for all a b c. (a -> b -> c) -> b -> a -> c **
flip is a __higher order function__. Its first argument is a function which takes two arguments.
Flip changes the order of the aruments.
#Example:#
    > let sub a b = a - b
    > sub 3 4
    > -1 : Number
    > flip sub 3 4
    > 1 : Number
*)
let flip f = \x y -> f y x;
(*
==twice==
***twice***
** twice :: for all a. (a -> a) -> a -> a **
twice takes a function and a value and applies the function to it twice
#Example:#
    > twice succ 4
    > 6 : Number
Why 6?
    > succ 5        **the first time through the function**
    > 5         
    > succ 5        **the second application of succ, this time with the new value**
    > 6
*)
let twice f x = f (f x);
(*
==pipe==
***pipe***
** pipe : for all a b. a -> (a -> b) -> b **
pipe takes a value and **pushes it through** a function (reading from left to right). 
#Example:#
    > pipe 5 succ
    > 6 : Number
    > pipe 5 (twice succ)
    > 7 : Number
*)
let pipe x f = f x;
(*
==compose==
***compose***
** compose : for all a b c. (a -> b) -> (c -> a) -> c -> b **
compose takes two functions and a value, passing the value through both functions (reading from
right to left).
#Example:#
    > compose double succ 4
    > 10 : Number
What has happened here?
    > succ 4        **succ is applied to the value 4**
    > 5             **the result is 5**
    > double 5      **5 is then passed to double**
    > 10            **and the result is 10**
*)
let compose f g x = f (g x);
(*
==end?==
***end?***
** end? :: [a] -> Boolean **
A shortcut for **if xs == []**. Helpful when defining a __recursive__ function on a list.
*)
let end? xs = if xs == [] then true else false;


-- TODO
-- | do not yet get past the type checker !! | --

--let length xs = if end? xs then 0 else 1 + (length (tail xs));
--let drop n xs = if (zero? n) then xs else (drop (n-1) (tail xs));
--let take n xs = if (zero? n) then ([]) else ((head xs) : (take (n-1) (tail xs)));

--let foldr f acc xs = if (end? xs) then acc else ((f (head xs)) (foldr f acc (tail xs)));
--let foldl f acc xs = if (end? xs) then acc else (foldl f (f acc (head xs)) (tail xs));
--let foldr1 f xs = foldr f (head xs) xs;
--let foldrl1 f xs = foldl f (head xs) xs;

--let map f xs = foldr (\x xs' -> (f x) : xs') ([]) xs;
--let filter p xs = foldr (\x y -> if (p x) then (x:y) else y) [] xs;
--let concat xs
--let concatMap xs
--let until p f x = if (p x) then x else (until p f (f x));
--let cons a b = a : b;
